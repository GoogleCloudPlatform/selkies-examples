# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: pod-broker-image-loader-${TIER}-${TS}
  namespace: pod-broker-system
  labels:
    app: pod-broker-image-loader
spec:
  selector:
    matchLabels:
      app: pod-broker-image-loader
  template:
    metadata:
      labels:
        app: pod-broker-image-loader
    spec:
      terminationGracePeriodSeconds: 2

      # Use host network to avoid wating for cni to initialize.
      hostNetwork: true

      nodeSelector:
        app.broker/tier: "${TIER}"

      # Only run on nodes that will host broker apps.
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: app.broker/tier
                    operator: Exists

      tolerations:
        - effect: "NoSchedule"
          operator: "Exists"

      volumes:
        ###
        # PVC containing cached images
        ###
        - name: pod-broker-image-cache
          persistentVolumeClaim:
            claimName: pod-broker-image-cache-${TS}
            readOnly: true

        ###
        # Root FS from host
        ###
        - name: hostfs
          hostPath:
            path: /
            type: Directory

      # Use the host PID namespace, required to perform mounts on host using nsenter.
      hostPID: true

      initContainers:
        ###
        # Loads images into docker from persistent disk.
        ###
        - name: image-loader
          image: ${LOADER_IMAGE}
          securityContext:
            privileged: true

          command: ["/bin/sh"]
          args:
            - -ec
            - |
              cat - | tee /hostfs/home/kubernetes/bin/inject-images.sh <<'EOF'
              #!/bin/bash
              until [[ -S /var/run/docker.sock ]]; do echo "Waiting for docker..."; sleep 1; done

              export PD_DOCKER_DIR=/home/kubernetes/containerized_mounter/rootfs/var/lib/kubelet/plugins/kubernetes.io/gce-pd/mounts/${PD_NAME}/var/lib/docker
              [[ ! -d ${PD_DOCKER_DIR} ]] && echo "ERROR: docker directory from persistent disk not found: $PD_DOCKER_DIR" && exit 1

              export PD_IMAGE_TAR_DIR=/home/kubernetes/containerized_mounter/rootfs/var/lib/kubelet/plugins/kubernetes.io/gce-pd/mounts/${PD_NAME}/mnt/empty-images
              [[ ! -d ${PD_IMAGE_TAR_DIR} ]] && echo "ERROR: image tarball directory from persistent disk not found: $PD_IMAGE_TAR_DIR" && exit 1

              function injectImage() {
                  local image_tar=$1
                  local name=$(basename $image_tar .tar)

                  # Load the empty image from the tarball    
                  local image=$(docker load < $image_tar | grep "Loaded image" | sed 's/Loaded image: //g')
                  echo "Loading: $image"

                  # Mount all image layers as merged read-only overlayfs to the empty-layer local dir.
                  local lower_dirs=$(cat $image_tar.layers)
                  local merged_dir=$(docker inspect ${image} -f '{{.GraphDriver.Data.UpperDir}}')

                  # Unmount the merged dir if already mounted, this is the case when a new daemonset runs with potentially updated images.
                  if mountpoint -q "${merged_dir}"; then
                    umount "${merged_dir}"
                  fi

                  # Perform mount from the overlay2 directory, this is beacuse the list of lower dirs are symlinks.
                  (cd ${PD_DOCKER_DIR}/overlay2 && mount -t overlay overlay -o lowerdir=${lower_dirs} ${merged_dir})
                  
                  docker tag $image ${image/:*/}:fixed
                  docker rmi ${image/:*/}:empty > /dev/null

                  local num_layers=$(echo $lower_dirs | tr ':' '\n' | wc -l)
                  echo "Loaded ${image/:empty/:fixed} with $num_layers mounted layers" >&2
              }
              export -f injectImage

              ls ${PD_IMAGE_TAR_DIR}/*.tar | xargs -I {} -P$(nproc) bash -c "injectImage {}"
              EOF
              chmod +x /hostfs/home/kubernetes/bin/inject-images.sh

              # Inject all images into docker engine using nsenter to run mount commands on host.
              nsenter -m/proc/1/ns/mnt /home/kubernetes/bin/inject-images.sh

              echo "Done loading images"
          env:
            - name: PD_NAME
              value: ${PD_NAME}
          volumeMounts:
            - name: pod-broker-image-cache
              mountPath: /mnt
              readOnly: true
            - name: hostfs
              mountPath: /hostfs

      containers:
        ###
        # Pause container to run in background.
        ###
        - name: pause
          image: gcr.io/google-containers/pause:2.0
